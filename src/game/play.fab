// shifts
fn handle_lr()
    if pads[0].held & BUTTON_DOWN > 0
        return
    if pads[0].held & (BUTTON_LEFT | BUTTON_RIGHT) == 0
        return
    // if l or r is pressed, we should reset das and actually move the piece
    if pads[0].pressed & (BUTTON_LEFT | BUTTON_RIGHT) > 0
        das_charge = 0
        try_shift_piece()
    // else if l or r is held, we increase das_charge and compare it with 16
    // if equal, shift the piece and set it to 10
    if pads[0].held & (BUTTON_LEFT | BUTTON_RIGHT) > 0
        das_charge += 1
        if S(das_charge) >= DAS_THRESHOLD()
            das_charge = DAS_CHECKPOINT()
            try_shift_piece()

fn try_shift_piece()
    U piece_x_tmp = piece_x
    if pads[0].held & BUTTON_RIGHT > 0
        piece_x += 1
    else if pads[0].held & BUTTON_LEFT > 0
        piece_x -= 1

    if is_position_valid()
        set_sfx(SFX_SHIFT_PIECE)
    else
        piece_x = piece_x_tmp
        das_charge = DAS_THRESHOLD()

// rotation
fn handle_ab()
    U piece_id_tmp = active_piece_id
    if pads[0].pressed & BUTTON_A > 0
        active_piece_id = cw_id_table[active_piece_id]
    else if pads[0].pressed & BUTTON_B > 0
        active_piece_id = ccw_id_table[active_piece_id]
    else
        return
    if is_position_valid()
        set_sfx(SFX_ROTATE_PIECE)
    else
        active_piece_id = piece_id_tmp

fn handle_gravity() U
    // initial delay behavior
    if S(secondary_fall_timer) < 0
        if pads[0].pressed & BUTTON_DOWN == 0
            secondary_fall_timer += 1
            return PLAY_STATE_GAME
        else
            secondary_fall_timer = 0
    if secondary_fall_timer == 0
        return normal_drop()
    return pushdown_drop()

fn normal_drop() U
    if pads[0].held & (BUTTON_LEFT | BUTTON_RIGHT) > 0
        return try_gravity_drop()
    if pads[0].pressed & BUTTON_DPAD == BUTTON_DOWN
        secondary_fall_timer = 1
    return try_gravity_drop()

// @autorepeating
fn pushdown_drop() U
    if pads[0].held & BUTTON_DPAD != BUTTON_DOWN
        secondary_fall_timer = 0
        pushdown = 0
        return try_gravity_drop()
    secondary_fall_timer += 1
    if secondary_fall_timer < 3
        return try_gravity_drop()
    secondary_fall_timer = 1
    pushdown += 1
    return try_drop()

fn try_gravity_drop() U
    U gravity = get_gravity(level_number)
    if S(gravity_timer) < gravity
        return PLAY_STATE_GAME
    return try_drop()

// returns the resulting playstate
fn try_drop() U 
    gravity_timer = 0
    piece_y += 1
    if !is_position_valid()
        piece_y -= 1
        set_board_vram_row()
        return PLAY_STATE_LOCK_PIECE
    return PLAY_STATE_GAME

fn set_board_vram_row()
    U new_vram_row = 0
    if S(piece_y) >= 2
        new_vram_row = piece_y - 2
    if S(new_vram_row) < vram_row
        vram_row = new_vram_row

fn get_gravity(U level) U
    if level >= 29
        return 1
    return GRAVITY_TABLE()[level]

fn is_position_valid() Bool
    PieceTileset tileset = get_piece_tileset(active_piece_id)
    for U i = 0; i < 4; i += 1
        PieceTile tile = tileset.tiles[i]
        U x = piece_x + tile.x_offset
        U y = piece_y + tile.y_offset
        // ensure x is in range
        if x >= 10 || x >= $80
            return false
        // ensure y is in range
        if (y+2) >= 22
            return false
        if board_get_cell(@board, x, y) != GAME_TILE_EMPTY
            return false
    return true
